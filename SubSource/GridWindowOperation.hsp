*ListDrag

	if (ginfo(24) == WND_GRID) {

			//縮小処理用
		buffer WND_TEMP1, maxScrSize(0)/5, maxScrSize(1)/3
			SET_WND_INFO
	
		//背景コピー用
		buffer WND_TEMP2, maxScrSize(0), maxScrSize(1)
			SET_WND_INFO
	
		gsel WND_GRID
		oncmd 0
			
			dragdata = 0
			repeat
				stick sti, 256
				//左クリック用の処理ここから-----
				if sti = 256{

					//------

					//mes (mousey\cellh+10)\cellh
					if ( (listMode == 0) and (cliFlag == FALSE) ){
						if (mousey > (cellsize(1)-10)){
							temph = (mousey\cellsize(1)+10)\cellsize(1)
							if ( (0 <= temph) and (temph <= 20) ){
								listModeHNum = (mousey+10)/cellsize(1)
								gosub *ChangeListModeHNum
								gosub *draw
								sti = 0
								cliflag = 0
							}
						}
					}


					//------

					
					//mxy はドラッグを話した時点の座標
					//mxy_ はドラッグ開始の座標
					mxy(0) = limit(kmmousex/cellsize(0), 0, cellnum(0)) , limit(kmmousey/cellsize(1), 0, cellnum(1))
					if (bufIDPos(mxy(0), mxy(1))) >= 100 & cliflag = 0{				
						cliflag = 1
						mxy_(0) = mxy(0), mxy(1)
						mindexxy(0) = (mousex-(mxy_(0)*(cellsize(0)-1))), (mousey-(mxy_(1)*(cellsize(1)-1)))				
						gsel WND_TEMP2
						pos 0, 0
						gcopy 1, 0, 0, maxScrSize(0), maxScrSize(1)
						gsel WND_TEMP1
						pos 0, 0
						gzoom cellsize(0), cellsize(1), bufIDPos(mxy_(0), mxy_(1)), cutRange(0), cutRange(1), cutRange(2), cutRange(3), 1
						gsel WND_GRID, 0
					}
				
				}
			
				if cliflag = 1{
					redraw 0
					pos 0, 0
					gcopy WND_TEMP2, 0, 0, maxScrSize(0), maxScrSize(1)
					gmode 4, cellsize(0), cellsize(1), 100
					pos mousex-mindexxy(0), mousey-mindexxy(1)
					gcopy WND_TEMP1, 0, 0, cellsize(0), cellsize(1)
					gmode 0
					redraw 1
				}
				
				if (sti == 0 and cliflag == 1){
					if (kmmousex < 0) | (kmmousex > scrsize(0)) | (kmmousey < 0) | (kmmousey > scrsize(1)){
						//マウス座標がウィンドウ外のとき
						if bufIDPos(mxy_(0), mxy_(1)) >= 100{
							loadPicBufID( bufIDPos(mxy_(0), mxy_(1)) - 100 ) = 0
							bufIDPos(mxy_(0), mxy_(1)) = 0
							gsel WND_MAIN
							logmessage = "セル("+mxy_(0)+", "+mxy_(1)+")を削除しました"
							objprm logid, logmessage
							gsel WND_GRID		
						}
					} else {
						temp = bufIDPos(mxy_(0), mxy_(1)) 
						bufIDPos(mxy_(0), mxy_(1)) = bufIDPos(mxy(0), mxy(1))
						bufIDPos(mxy(0), mxy(1)) = temp
						gsel WND_MAIN
						logmessage = "セル("+mxy_(0)+", "+mxy_(1)+")をセル("+mxy(0)+", "+mxy(1)+")に移動しました"
						objprm logid, logmessage
						gsel WND_GRID
					}
			
					mxy(0) = 0, 0
					mxy_(0) = 0, 0
					temp = 0
					cliflag = 0
					gosub *draw
				}
			
				if sti = 0 & cliflag = 0{
					break
				}
				//左クリック用の処理ここまで-----

				
		
				await 16
			loop

		oncmd 1
	}
	
return



*ListRelocation

	if (ginfo(24) != WND_GRID) :return
	gsel WND_GRID
	
	
	oncmd 0
	repeat

		stick sti, 512

		//右クリック用の処理ここから-----

		if (sti == 512){
			if (RCliFlag == FALSE){
				staMPos = ginfo_mx, ginfo_my
				MoveWindow WND_INFO(WND_OVERLAY, WI_HANDLE), 0, 0, 0, 0, 1
				gsel WND_OVERLAY, 2
				gsel WND_GRID
				RCliFlag = TRUE
			}
			if (RCliFlag){

				dragW = abs(staMPos(0)-ginfo_mx)
				dragH = abs(staMPos(1)-ginfo_my)

				if staMPos(0) < ginfo_mx: overRlayWndX = staMPos(0): else: overRlayWndX = ginfo_mx
				if staMPos(1) < ginfo_my: overRlayWndY = staMPos(1): else: overRlayWndY = ginfo_my

				
				MoveWindow WND_INFO(WND_OVERLAY, WI_HANDLE), overRlayWndX, overRlayWndY, dragW, dragH, 1
			}
		}

		if (sti == 0) & RCliFlag{
			title "しゅうｒ"
			gsel WND_OVERLAY, -1
			gsel WND_GRID
			RCliFlag = FALSE
			break
		}
		//右クリック用の処理ここまで-----

		await 16

	loop


	oncmd 1

return




//描画――――――――――――――――――――――――――――――――――
*draw
	
	gsel WND_GRID, 0
	redraw 0
	
	color 255, 255, 255
	boxf
	color 150, 150, 150
	
	pos int(0.33333334*scrsize(0)), 20
	gzoom int(0.66666667*scrsize(0)), int(0.15625*scrsize(0)), WND_GRID_STRING, 0, 0, 640, 150
	
	repeat cellnum(0), 1
		line cnt*cellsize(0), -1, cnt*cellsize(0), maxScrSize(1)+1
	loop
	repeat cellnum(1), 1
		line -1, cnt*cellsize(1), maxScrSize(0)+1, cnt*cellsize(1)
	loop
	
	repeat cellnum(1)+1
		ycnt = cnt
		repeat cellnum(0)+1
			if bufIDPos(cnt, ycnt) >= 100{
				pos cnt*cellsize(0), ycnt*cellsize(1)
				//assert
				gzoom cellsize(0), cellsize(1), bufIDPos(cnt, ycnt), cutRange(0), cutRange(1), cutRange(2), cutRange(3), 1
			}
		loop
	loop

	If (listMode == 0){

		color 32, 32, 192
		boxf -1, cellsize(1)*listModeHNum-2, maxScrSize(0)+1, cellsize(1)*listModeHNum
		color 0, 0, 0

	}
	
	if (mode = 2) & fleetPunctuation{
		color 32, 32, 192
		if tuika1 {
			boxf 2*cellsize(0)-1, -1, 2*cellsize(0)+1, maxScrSize(1)+1
			boxf 4*cellsize(0)-1, -1, 4*cellsize(0)+1, maxScrSize(1)+1
			boxf -1, cellsize(1)*3-1, maxScrSize(0)+1, cellsize(1)*3+1
		}
		if tuika2 {
			boxf -1, cellsize(1)-1, maxScrSize(0)+1, cellsize(1)+1
			boxf -1, cellsize(1)*2-1, maxScrSize(0)+1, cellsize(1)*2+1
			boxf -1, cellsize(1)*3-1, maxScrSize(0)+1, cellsize(1)*3+1
			boxf -1, cellsize(1)*4-1, maxScrSize(0)+1, cellsize(1)*4+1
			boxf -1, cellsize(1)*5-1, maxScrSize(0)+1, cellsize(1)*5+1
			
		}
		if tuika3 {
			boxf cellsize(0)-1, -1, cellsize(0)+1, maxScrSize(1)+1
			boxf cellsize(0)*2-1, -1, cellsize(0)*2+1, maxScrSize(1)+1
			boxf cellsize(0)*3-1, -1, cellsize(0)*3+1, maxScrSize(1)+1
			boxf cellsize(0)*4-1, -1, cellsize(0)*4+1, maxScrSize(1)+1
			boxf cellsize(0)*5-1, -1, cellsize(0)*5+1, maxScrSize(1)+1
		}
	
		if tuika4 {
			boxf 3*cellsize(0)-1, -1, 3*cellsize(0)+1, maxScrSize(1)+1
			boxf -1, cellsize(1)*2-1, maxScrSize(0)+1, cellsize(1)*2+1
			boxf -1, cellsize(1)*4-1, maxScrSize(0)+1, cellsize(1)*4+1
		}
		
		color 0, 0, 0
		
	}
	
	redraw 1
return


*ChangeListModeHNum


	//配列を複製
	dim temp_bufIDPos, CELL_MAX_W, CELL_MAX_H
	repeat CELL_MAX_H
		cntY = cnt
		repeat CELL_MAX_W
			cntX = cnt
			temp_bufIDPos(cntX, cntY) = bufIDPos(cntX, cntY)
			bufIDPos(cntX, cntY) = 0
		loop
	loop

	//最大配置数を計算
	maxCount = (cellNum(0)+1)*ListModeHNum
	count = 0

	repeat (cellNum(0)+1) * (cellNum(1)+1)
		//順番に見て存在したら再配置
		if temp_bufIDPos(cnt/(cellnum(1)+1), cnt\(cellnum(1)+1)) >= 100{
			bufIDPos(count/ListModeHNum, count\ListModeHNum) = temp_bufIDPos(cnt/(cellnum(1)+1), cnt\(cellnum(1)+1))
			count++
		}
		//最大配置数になったら抜ける
		if (maxCount == count) :break
	loop

return