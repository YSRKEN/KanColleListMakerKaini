
*VideoCap

	nidPush

	if (audioDeviceName == ""){
		gsel WND_MAIN
		
		dialog "オーディオデバイスが選択されていません。\n設定画面を開きますか？",2
		if (stat == 6){
			mode = MODE_OPTION
			optionMode = OPMODE_VIDEOCAPTURE
			gosub *drawMainWindow
		
			optionModePrev = 0
			modePrev = mode

			nidPop
			return
		} else {
			logmessage = "動画キャプチャを中止しました。"
			objprm logid, logmessage: await
			
			nidPop
			return
		}
	}
	
	if (videoCapFlg == FALSE){
		
		switch captureMethod
	
		case CM_BITBLT
			switch positionType
				case PT_RELATIVE
				case PT_WNDABSOLUTE
					scrPoint = sscap(0), sscap(1)
					ClientToScreen hClient, varptr(scrPoint)
					capX = scrPoint(0)
					capY = scrPoint(1)
					swbreak
				case PT_ABSOLUTE
					capX = sscap(0)
					capY = sscap(1)
					swbreak
			swend
			swbreak
			
		case CM_PRINTWINDOW
			scrPoint = sscap(0), sscap(1)
			ClientToScreen hClient, varptr(scrPoint)
			capX = scrPoint(0)
			capY = scrPoint(1)
			swbreak

		swend

		sdim buf, 1024*10
		sdim buf1, 1024*10
		sdim buf2, 1024*10
		sdim elapsedTimeStr, 1024

		videoCapSizeX = int((0.125*sscapwh(0))+0.9999999)*8
		videoCapSizeY = int((0.125*sscapwh(1))+0.9999999)*8

		//音声なしならフラグを立てる
		noAudioFlg = FALSE
		if (audioDeviceName == "音声なし"): noAudioFlg = TRUE

		//x264のプリセットを文字で取得する
		x264presetStr = ""
		notesel x264presetList
		noteget x264presetStr, x264presetNum
		noteunsel


		fname = strf("%s\\%s", videoCapSaveDir, DateAndTimeFormat2(saveNameVideoCapture))


		if (noAudioFlg^1){
			//オーデイオあり
			cmda = strf("\"%s\" -vn -f dshow -i audio=\"%s\" -acodec aac -b:a 96k \"%s_a.aac\"", ffmpegdir, audioDeviceName, fname)
			if (lateEncode){
				//オーデイオ有り負荷軽減動画キャプチャ
				cmdv  = strf("\"%s\" -an -f gdigrab -video_size %dx%d -offset_x %d -offset_y %d ", ffmpegdir, videoCapSizeX, videoCapSizeY, capX, capY)
				cmdv += strf("-framerate %d -i desktop -vf fps=%d -pix_fmt yuv420p -c:v libx264 -crf 12 -preset ultrafast \"%s_v.mp4\"", videoCapFR,videoCapFR, fname)
				cmdm = strf("\"%s\" -i \"%s_v.mp4\" -i \"%s_a.aac\" -c:v libx264 -crf %d -preset %s -c:a copy \"%s.mp4\"", ffmpegdir, fname, fname, videoCapCRF, x264presetStr, fname)
			} else {
				//オーデイオ有り従来の動画キャプチャ
				cmdv  = strf("\"%s\" -an -f gdigrab -video_size %dx%d -offset_x %d -offset_y %d ", ffmpegdir, videoCapSizeX, videoCapSizeY, capX, capY)
				cmdv += strf("-framerate %d/1 -i desktop -vf fps=%d -pix_fmt yuv420p -c:v libx264 -crf %d -preset %s \"%s_v.mp4\"", videoCapFR, videoCapFR, videoCapCRF, x264presetStr, fname)
				cmdm = strf("\"%s\" -i \"%s_v.mp4\" -i \"%s_a.aac\" -c:v copy -c:a copy \"%s.mp4\"", ffmpegdir, fname, fname, fname)
			}
		} else {
			cmda = strf("cmd")
			if (lateEncode){
				//オーデイオ無し負荷軽減動画キャプチャ
				cmdv  = strf("\"%s\" -an -f gdigrab -video_size %dx%d -offset_x %d -offset_y %d ", ffmpegdir, videoCapSizeX, videoCapSizeY, capX, capY)
				cmdv += strf("-framerate %d/1 -i desktop -vf fps=%d -pix_fmt yuv420p -c:v libx264 -crf 12 -preset ultrafast \"%s_v.mp4\"", videoCapFR, videoCapFR, fname)
				cmdm = strf("\"%s\" -i \"%s_v.mp4\" -c:v libx264 -crf %d -preset %s \"%s.mp4\"", ffmpegdir, fname, videoCapCRF, x264presetStr, fname)
			} else {
				//オーデイオなし従来の動画キャプチャ
				cmdv  = strf("\"%s\" -an -f gdigrab -video_size %dx%d -offset_x %d -offset_y %d ", ffmpegdir, videoCapSizeX, videoCapSizeY, capX, capY)
				cmdv += strf("-framerate %d/1 -i desktop -vf fps=%d -pix_fmt yuv420p -c:v libx264 -crf %d -preset %s \"%s.mp4\"", videoCapFR, videoCapFR, videoCapCRF, x264presetStr, fname)
			}
		}
		//dialog ""+cmdv

		//gsel WND_FFMPEG, 1
		gsel WND_MAIN

		apid = 0
		vpid = 0

		pipe2exec cmda
		apid = stat
		pipe2exec cmdv
		vpid = stat

		if ( (apid == -1) || (vpid == -1) ){
			LogOut "動画キャプチャの開始に失敗しました"
			return
		}

		videoCapStartTime = timeGetTime()

		gsel WND_MAIN, 0
		SetTimer WND_INFO(WND_MAIN, WI_HANDLE), VideoCapTimerID, 400, 0

		videoCapFlg = TRUE
		videoCapMes = "停止"
		objprm videoCapBId, videoCapMes
		
		gosub *SSModeControlDisable

		
	
	} else {

		gsel WND_MAIN
		objenable videoCapBId, 0
		
		videoCapFlg = FALSE
		KillTimer WND_INFO(WND_MAIN, WI_HANDLE), VideoCapTimerID

		videoCapTime = timeGetTime() - videoCapStartTime

		if (noAudioFlg^1){
			pipe2put apid, "q" //録音の停止
		} else {
			pipe2put apid, "exit\n"
		}
		pipe2put vpid, "q" //動画キャプチャの停止
	
		exf = 0
		exfv = 0
		exfa = 0
		repeat //終了の待機
			if (exfv == 0){
				pipe2check vpid
				if stat == 0:exfv = 1
				if stat & 2: pipe2get vpid, buf
				if stat & 4: pipe2err vpid, buf
			}
			if (exfa == 0){
				pipe2check apid
				if stat == 0:exfa = 1
				if stat & 2: pipe2get apid, buf
				if stat & 4: pipe2err apid, buf
			}
			if (exfv && exfa): break
			wait 10
		loop

		pipe2term vpid
		pipe2term apid
		
		LateEncodeFlg = FALSE
		
		if ( (noAudioFlg^1) || lateEncode ){
			//動画結合処理

			LateEncodeFlg = TRUE
			lateEncodeStartTime = timeGetTime()
			
			pipe2exec cmdm
			mpid = stat

			if ( mpid == -1 ){
				LogOut "エンコードプロセスの開始に失敗しました"
				
				gsel WND_MAIN, 1+frontRow
				videoCapMes = "開始"
				objprm videoCapBId, videoCapMes
				
				nidPop
				return
			}
			
			SetTimer WND_INFO(WND_MAIN, WI_HANDLE), LateEncodeTimerID, 1500, 0
			
		}

		gosub *SSModeControlEnable

		if (LateEncodeFlg^1){
			//エンコード中でないなら
			gosub *VidepCapFinish
		}

	}
	nidPop
return

*VideoCapTimerProcessing

	nidPush

	exfv = 0
	exfa = 0

	gsel WND_FFMPEG

	pipe2check vpid
	if (stat == 0):exfv = 1
	if (stat & 2): pipe2get vpid, buf1
	if (stat & 4): pipe2err vpid, buf1
	//objprm 0, buf1: await

	pipe2check apid
	if (stat == 0):exfa = 1
	if (stat & 2): pipe2get apid, buf2
	if (stat & 4): pipe2err apid, buf2
	//objprm 1, buf2: await

	gsel WND_MAIN
	
	if (exfv || exfa){
		gosub *VideoCapEmgStop
		
		logmessage =  "Error-動画キャプチャを停止しました\n"
		if (exfv): logmessage += "動画プロセスが異常停止しました\n"
		if (exfa): logmessage += "音声プロセスが異常停止しました\n"
		
		LogOut logmessage
		nidPop
		return
	}

	elapsedTime = timeGetTime() - videoCapStartTime
	elapsedTimeStr = "動画をキャプチャ中…\n"
	elapsedTimeStr += strf("  経過時間 %02d:%02d.%03d", (elapsedTime/1000/60), (elapsedTime/1000\60), (elapsedTime\1000))

	gsel WND_MAIN
	objprm logId, elapsedTimeStr: await
	
	nidPop
return

*LateEncodeTimerProcessing

	nidPush

	exfm = 0

	gsel WND_FFMPEG

	pipe2check mpid
	if (stat == 0): exfm = 1
	if (stat & 2): pipe2get mpid, buf1
	if (stat & 4): pipe2err mpid, buf1
	//objprm 0, buf1: await

	strrep buf1, "\r", "\n"
	strrep buf1, "\r\r", "\r"

	lastStr = ""
	notesel buf1
	noteget lastStr, notemax-1
	noteunsel


	gsel WND_MAIN
	
	if (exfm){

		lateEncodeFlg = FALSE
		KillTimer WND_INFO(WND_MAIN, WI_HANDLE), LateEncodeTimerID
		
		gosub *VidepCapFinish
		return
		/*
		gosub *VideoCapEmgStop
		
		logmessage =  "Error-動画キャプチャを停止しました\n"
		logmessage += "エンコードプロセスが異常停止しました\n"
		
		LogOut logmessage
		nidPop
		return
		*/
	}

	getstr lastStr, lastStr, instr(lastStr, 0, "time=")+5, ' '
	encodeElapsedTime = int(strmid(lastStr, 0, 2))*3600000 + int(strmid(lastStr, 3, 2))*60000 + int(double(strmid(lastStr, 6, 5))*1000.0)
	//↑エンコード側の経過時間(ms)
	encodeTime = timeGetTime() - lateEncodeStartTime
	//↑リアルタイムの経過時間

	encodeSpeed = 1.0*encodeElapsedTime/encodeTime

	//予想エンコード時間
	estimatedTime = 1.0*videoCapTime/(encodeSpeed+0.00000000001)

	remainingTime = estimatedTime-encodeTime

	if (remainingTime < 0.0): remainingTime = 0.0

	
	lateEncodeStr = "動画をエンコード中…\n"
	lateEncodeStr += strf("  経過時間 %02d:%02d.%03d\n", (encodeTime/1000/60), (encodeTime/1000\60), (encodeTime\1000))
	lateEncodeStr += strf("  推定残り %02d:%02d.%03d", (remainingTime/1000/60), (remainingTime/1000\60), (remainingTime\1000))

	LogOut lateEncodeStr
	
	nidPop
return


*VidepCapFinish
	nidPush

	exist fname+"_v.mp4"
	//if (strsize != -1): delete fname+"_v.mp4"
	exist fname+"_a.aac"
	//if (strsize != -1): delete fname+"_a.aac"

	gsel WND_MAIN
	LogOut strf("%s.mp4を保存しました。", getpath(fname, 8))

	videoCapMes = "開始"
	objprm videoCapBId, videoCapMes

	gosub *SSModeControlEnable
	
	nidPop
return


*VideoCapEmgStop

	logmes "異常停止の発生"

	videoCapFlg = FALSE

	KillTimer WND_INFO(WND_MAIN, WI_HANDLE), VideoCapTimerID
	pipe2term apid
	pipe2term vpid
	wait 50
	exist fname+"_v.mp4"
	if (strsize != -1): delete fname+"_v.mp4"
	exist fname+"_a.aac"
	if (strsize != -1): delete fname+"_a.aac"
	exist fname+".mp4"
	if (strsize != -1): delete fname+".mp4"

	gsel WND_MAIN, 1+frontRow
	videoCapMes = "開始"
	objprm videoCapBId, videoCapMes
		
	gosub *SSModeControlEnable

return


*VideoCapSetting
	//audioDeviceNameからaudioDeviceListNumを取得するためのサブルーチン
	//起動時に一度だけ呼び出される

	GetAudioDevice ffmpegdir, audioDeviceList
	audioDeviceList += "音声なし"
	audioDeviceListNum = -1
	if (audioDeviceName != ""){
		notesel audioDeviceList
		repeat notemax
			noteget tempStr, cnt
			if (audioDeviceName == tempStr){
				audioDeviceListNum = cnt
				break
			}
		loop
		noteunsel
		if (audioDeviceListNum == -1){
			audioDeviceName = ""
		}
	}
	
return

*SetAudioDeviceName
	//リストボックスをクリックした時に呼び出されるサブルーチン
	//WindowMessageEventからクリックするたびに呼び出される

	sendmsg hAudioDeviceLB, LB_GETCURSEL
	audioDeviceListNum = stat
	notesel audioDeviceList
	noteget audioDeviceName, audioDeviceListNum
	noteunsel

	logmes "audioDeviceName :"+audioDeviceName
	
return


*openDialogffmpeg
	//ffmpeg探すダイアログを開くためのサブルーチン
	//ボタンを押す度に呼び出される

	nidPush

	gsel WND_MAIN

	dialog "exe", 16, "ffmpeg.exe"
	if (stat==1){
		ffmpegdir = refstr
	} else {
		ffmpegdir = ""
	}
	
	objprm ffmpegDirIId, ffmpegdir: await

	GetAudioDevice ffmpegdir, audioDeviceList
	audioDeviceList += "音声なし"
	objprm audioDeviceLBId, audioDeviceList: await
	audioDeviceListNum = -1
	audioDeviceName = ""
	sendmsg hAudioDeviceLB, LB_SETCURSEL, audioDeviceListNum, 0

	nidPop

return