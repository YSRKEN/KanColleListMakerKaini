
//, 
*SSCaptureOnMemory

	nidPush
	gsel WND_MAIN

	if (positionType == PT_RELATIVE){
		if (IsWindow(hClient) == 0){

			ssCap(0) = 0, 0, 0, 0
			hClient = 0
			ReleaseDC dcClient
			if seqCapf: gosub *seqcap

			gosub *ssSettingCheck
			
			logmessage = "艦これの画面を見失いました"
			if (mode != MODE_OPTION){
				objprm logid, logmessage
			}

			nidPop
			return
		}

		GetClientRect hClient, varptr(rect)
		if (clientSize(0) != (rect(2)-rect(0))) | (clientSize(1) != (rect(3)-rect(1))){

			ssCap(0) = 0, 0, 0, 0
			hClient = 0
			ReleaseDC dcClient
			if seqCapf: gosub *seqcap
			
			gosub *ssSettingCheck
			
			logmessage = "艦これの画面を見失いました"
			if (mode != MODE_OPTION){
				objprm logid, logmessage
			}
			
			nidPop
			return
		}
			
	}
	
	//暫定数値直接入力
	sscap(0) = luposx
	sscap(1) = luposy
	sscap(2) = rdposx
	sscap(3) = rdposy
	sscapwh(0) = sscap(2)-sscap(0), sscap(3)-sscap(1)

	if (positionType == PT_ABSOLUTE){
		ssCapMes = strf("%d, %d", 　sscap(0), 　sscap(1))
	} else {
		ssCapMes = "追跡中"
	}
	
	if (mode != MODE_OPTION){
		objprm sscapiid, ssCapMes
	}
	
	if ( (sscapwh(0) < 50) | (sscapwh(1) < 30) ){
		if (mode != MODE_OPTION){

			if seqCapf: gosub *seqcap
			
			positionType = 0
			logmessage = "取得範囲が小さすぎます"
			objprm logid, logmessage

			ssCapMes = "取得する"
			objprm sscapiid, ssCapMes
			
		}
		nidPop
		return
	}
		

	buffer WND_CAPTURE, sscapwh(0), sscapwh(1)

	switch captureMethod
	
		case CM_BITBLT
			switch positionType
				case PT_RELATIVE
					BitBlt hdc, 0, 0, sscapwh(0), sscapwh(1), dcClient, sscap(0), sscap(1), SRCCOPY | CAPTUREBLT: redraw
					swbreak
				case PT_ABSOLUTE
					BitBlt hdc, 0, 0, sscapwh(0), sscapwh(1), hdcScreen, sscap(0), sscap(1), SRCCOPY | CAPTUREBLT: redraw
					swbreak	
			swend
			swbreak
			
		case CM_PRINTWINDOW
			buffer WND_TEMP1, clientSize(0), clientSize(1)
			PrintWindow hClient, hdc, 1
			redraw
	
			gsel WND_CAPTURE
			gcopy WND_TEMP1, sscap(0), sscap(1), sscapwh(0), sscapwh(1)
			swbreak

	swend

	nidPop
	
return
	

//SSキャプチャ――――――――――――――――――――――――――――――――――
*SSCapture

	nidPush
	
	gosub *SSCaptureOnMemory

	buffer WND_TEMP1, sscapwh(0), sscapwh(1)
	gcopy WND_CAPTURE, 0, 0, sscapwh(0), sscapwh(1) 

	if (hidename && isHomeport(WND_TEMP1)){

		if (namecut){
			//バッファを初期化し直し上部をカット
			buffer WND_TEMP1, sscapwh(0), int(0.9375*sscapwh(1)+0.5)
			gcopy WND_CAPTURE, 0, 0, sscapwh(0), int(0.9375*sscapwh(1)+0.5)
		} else {
			//提督名とレベルを隠す処理
			pos 0.14125*sscapwh(0), 0
			gzoom 0.20375*sscapwh(0), 0.05*sscapwh(1), WND_IMAGE_BUF, 0, 0, 163, 24, 1
			pos 0.49375*sscapwh(0), 0.0208333333*sscapwh(1)+0.9
			gzoom 0.125*sscapwh(0), 0.0333333333*sscapwh(1)+0.5, WND_IMAGE_BUF, 0, 24, 100, 16, 1
			
		}
	
	}

	saveName = strf("%s%s", DateAndTimeFormat2(saveNameCapture), savekind(jpgsave))
	
	if (seqCapf == FALSE){
		saveNamePath = ssSaveDir +"\\"+ saveName
		gdiImageSave ssSaveDir +"\\"+ saveName, jpgQuality
	} else {
		saveNamePath = intervalShotDir+"\\"+intervalSaveDir+"\\" +saveName
		gdiImageSave intervalShotDir+"\\"+intervalSaveDir+"\\" +saveName, jpgQuality
	}

	gsel WND_MAIN
	
	if (mode != MODE_OPTION){
		if kmexist(savenamepath) <= 0{
			logmessage = savename+"の保存に失敗しました"
		} else {
			logmessage = savename+"を保存しました"
			if dispcap & (mode == MODE_SSCAP){
				pos 0, dispcapy
				gzoom Scale(175), Scale(105), WND_TEMP1, 0, 0, sscapwh(0), sscapwh(1), 1
			}
			
			if (seqcapf^1) {
					
				picHistoryCount++
				if picHistoryCount > 100: picHistoryCount = 100
				
				i = picHistoryNum
				repeat picHistoryNum
					PicHistory(i) = PicHistory(i-1)
					i--
				loop
				PicHistory(0) = savenamepath 
				gosub *TweetWindow
			}
			
		}
		objprm logid, logmessage
	}

	nidPop
return


*addCapture

	gsel WND_GRID, 0

	if ( dropFlag & (dropWindowId == 1) ){
		xcnt = dragPoint(0)/cellsize(0) 
		ycnt = dragPoint(1)/cellsize(1)
		dmxy(0) = xcnt, ycnt
		if bufIDPos(xcnt, ycnt) >= 100{
			dmxy(0) = xcnt, ycnt
			loadPicBufID(bufIDPos(xcnt, ycnt)-100) = 0
		}
		
	} else: if ( hotKeyFlag && autoAddCapture){

		repeat
			if (listmode == LISTMODE_LIST){
				ycnt = cnt\ListModeHNum
				xcnt = cnt/ListModeHNum
			} 
			if (listmode == LISTMODE_FLEET){
				if tuika1{
					xcnt = (((cnt\(6*(cellnum(0)+1)/2))/6)*2)+(cnt\2)
					ycnt = ((cnt/((cellnum(0)+1)*3))*3)+((cnt\6)/2)
				}
				if tuika4{
					xcnt = (((cnt\(6*(cellnum(0)+1)/3))/6)*3)+(cnt\3)
					ycnt = ((cnt/((cellnum(0)+1)*2))*2)+((cnt\6)/3)
				}
				if tuika2 {
					xcnt = cnt\6
					ycnt = cnt/6
				}
				if tuika3{
					xcnt = cnt/6
					ycnt = cnt\6
				}
			}
			if (listmode == LISTMODE_OTHER){
				ycnt = cnt\(cellnum(1)+1)
				xcnt = cnt/(cellnum(1)+1)
			} 
			xcnt = limit(xcnt, 0, cellnum(0))
			ycnt = limit(ycnt, 0, cellnum(1))
			if (bufIDPos(xcnt, ycnt) == 0){
				dmxy(0) = xcnt, ycnt
				break
			}
			if (listMode != 0){
				if (xcnt=cellnum(0)) & (ycnt=cellnum(1)){
					dmxy(0) = xcnt, ycnt
					loadPicBufID(bufIDPos(xcnt, ycnt)-100) = 0
					break
				}
			} else {
				if (xcnt=cellnum(0)) & (ycnt=(ListModeHNum-1)){
					dmxy(0) = xcnt, ycnt
					loadPicBufID(bufIDPos(xcnt, ycnt)-100) = 0
					break
				}
			}
		loop
		
	}

	repeat (CELL_MAX_W*CELL_MAX_H)
		if loadPicBufID(cnt) = 0{
			loadPicBufID(cnt) = 1
			bufid = cnt +100
			break
		}
	loop
	
	bufIDPos(dmxy(0), dmxy(1)) = bufid
			
	if (hotKeyFlag && autoAddNonSave) {

		gsel WND_CAPTURE
		picx = ginfo_winx
		picy = ginfo_winy
		buffer bufid, 800, 480
		gzoom 800, 480,  WND_CAPTURE, 0, 0, picx, picy, 1
		logmessage = strf("画像をセル(%d, %d)に読み込みました", dmxy(0), dmxy(1))
		
	} else {
		
		ImgF_GetPicSize addFileName, picx, picy
	
		if ( (picx != 480) & (picy != 450) ){
			buffer bufid, limit(picx, 800, picx), limit(picy, 480, picy)
			ImgF_PicloadEx addFileName, 1
			gzoom 800, 480, bufid, 0, 0, picx, picy, 1
		} else {
			if (picy == 480){
				buffer bufid, 800, 480
				pos 0, 0
				ImgF_PicloadEx addFileName, 1
			}
			if (picy == 450){
				buffer bufid, 800, 480
				pos 0, 30
				ImgF_PicloadEx addFileName, 1
			}
		}
		logmessage = strf("%sをセル(%d, %d)に読み込みました", getpath(addfilename, 11), dmxy(0), dmxy(1))
		
	}


	gsel WND_GRID
	gosub *draw
	
	gsel WND_MAIN
	objprm logid, logmessage
	
	gsel WND_GRID

return


//ホットキー――――――――――――――――――――――――――――――――――
*hotkey
	nidPush
	
	if (wparam = HOTKEYID) & (availablecap = 1){

		hotKeyFlag = TRUE

		//通常のホットキーによるキャプチャ
		if (mode == MODE_SSCAP){
			gosub *ssCapture
		}

		//一覧作成モードの自動追加ありのキャプチャ
		if ( (mode != MODE_SSCAP) && (mode != MODE_OPTION) && autoAddCapture ) {
			if autoAddNonSave{
				//保存なしの場合
				gosub *SSCaptureOnMemory
			} else {
				//保存ありの場合
				gosub *SSCapture
				addFileName = saveNamePath
			}
			//追加
			gosub *addCapture

		}

		hotKeyFlag = FALSE
		addfilename = ""
	}
	
	nidPop
return

*seqcap
	
	if (seqcapf == FALSE){
		
		seqcapf = TRUE
		
		SetTimer WND_INFO(WND_MAIN, WI_HANDLE), timerID, 100*timersec, 0
		seqcapmes = "停止"
		objprm seqcapBId, seqcapmes
		
		objenable comboxId, 0
		objenable sscapBId, 0
		objenable sscapIId, 0
		objenable yabumiBId, 0

		objenable luposxIId, 0
		objenable luposyIId, 0
		objenable rdposxIId, 0
		objenable rdposyIId, 0
	
		chdir intervalShotDir
		intervalsavedir = strf("IntervalShot%04d%02d%02d-%02d%02d%02d", gettime(0), gettime(1), gettime(3), gettime(4), gettime(5), gettime(6))
		if PathIsDirectory(intervalShotDir+"\\"+intervalsavedir) = 0 {
			mkdir intervalsavedir
		}
		chdir currentdir
		
		gosub *ssCapture
	} else {
		
		seqcapf = FALSE
		
		KillTimer WND_INFO(WND_MAIN, WI_HANDLE), timerID
		seqcapmes = "開始"
		objprm seqcapBId, seqcapmes

		objenable comboxId, 1
		objenable SSCapIId, 1

		if availableCap | manualpos{
			objenable SSCapBId, 1
		}
		if availableCap: objenable yabumiBId, 1	
			
		objenable luposxIId, 1
		objenable luposyIId, 1
		objenable rdposxIId, 1
		objenable rdposyIId, 1

	}
return