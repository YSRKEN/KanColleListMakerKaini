 
*SSCaptureOnMemory

	nidPush
	gsel WND_MAIN

	if (positionType == PT_RELATIVE || positionType = PT_WNDABSOLUTE){
		
		if (IsWindow(hClient) == 0){

			ssCap(0) = 0, 0, 0, 0
			hClient = 0
			ReleaseDC dcClient
			if seqCapf: gosub *seqcap

			gosub *ssSettingCheck
			
			logmessage = "艦これの画面を見失いました(1)"
			if (mode != MODE_OPTION){
				objprm logid, logmessage: await
			}

			nidPop
			return 1
		}

		if (positionType==PT_RELATIVE){
	
			GetClientRect hClient, varptr(rect)
			if (clientSize(0) != (rect(2)-rect(0))) | (clientSize(1) != (rect(3)-rect(1))){
	
				ssCap(0) = 0, 0, 0, 0
				hClient = 0
				ReleaseDC dcClient
				if seqCapf: gosub *seqcap
				
				gosub *ssSettingCheck
				
				logmessage = "艦これの画面を見失いました(2)"
				if (mode != MODE_OPTION){
					objprm logid, logmessage: await
				}
				
				nidPop
				return 1
			}
		}
			
	}
	
	//暫定数値直接入力
	sscap(0) = luposx
	sscap(1) = luposy
	sscap(2) = rdposx
	sscap(3) = rdposy
	sscapwh(0) = sscap(2)-sscap(0), sscap(3)-sscap(1)

	switch positionType
		case PT_ABSOLUTE
			ssCapMes = strf("%d,%d",　sscap(0),　sscap(1))
			swbreak
		case PT_RELATIVE
			ssCapMes = "追跡中S"
			swbreak
		case PT_WNDABSOLUTE
			ssCapMes = "追跡中A"
			swbreak
	swend
	
	if (mode != MODE_OPTION){
		objprm SSCapIId, ssCapMes
	}
	
	if ( (sscapwh(0) < 50) | (sscapwh(1) < 30) ){
		if (mode != MODE_OPTION){

			if seqCapf: gosub *seqcap
			
			positionType = 0
			logmessage = "取得範囲が小さすぎます"
			objprm logid, logmessage

			ssCapMes = "取得する"
			objprm SSCapIId, ssCapMes
			
		}
		nidPop
		return 1
	}

	
	buffer WND_TEMP1, sscapwh(0), sscapwh(1)

	switch captureMethod
	
		case CM_BITBLT
			switch positionType
				case PT_RELATIVE
					logmes "PT_RELATIVE"
					BitBlt hdc, 0, 0, sscapwh(0), sscapwh(1), dcClient, sscap(0), sscap(1), SRCCOPY | CAPTUREBLT: redraw
					swbreak
				case PT_ABSOLUTE
					logmes "PT_ABSOLUTE"
					BitBlt hdc, 0, 0, sscapwh(0), sscapwh(1), hdcScreen, sscap(0), sscap(1), SRCCOPY | CAPTUREBLT: redraw
					swbreak

				case PT_WNDABSOLUTE
					logmes "PT_WNDABSOLUTE"
					scrPoint = sscap(0), sscap(1)
					ClientToScreen hClient, varptr(scrPoint)
					BitBlt hdc, 0, 0, sscapwh(0), sscapwh(1), hdcScreen, scrPoint(0), scrPoint(1), SRCCOPY | CAPTUREBLT: redraw
					swbreak
			swend
			swbreak
			
		case CM_PRINTWINDOW
			buffer WND_TEMP2, clientSize(0), clientSize(1)
			PrintWindow hClient, hdc, 1
			redraw
	
			gsel WND_TEMP1
			gcopy WND_TEMP2, sscap(0), sscap(1), sscapwh(0), sscapwh(1)
			swbreak

	swend

	if (hidename && isHomeport(WND_TEMP1)){
		if (namecut){
			//バッファを初期化し直し上部をカット
			buffer WND_CAPTURE, sscapwh(0), int(0.9375*sscapwh(1)+0.5)
			gcopy WND_TEMP1, 0, int(0.0625*sscapwh(1)+0.5), sscapwh(0), int(0.9375*sscapwh(1)+0.5)
		} else {
			//提督名とレベルを隠す処理
			buffer WND_CAPTURE, sscapwh(0), sscapwh(1)
			gcopy WND_TEMP1, 0, 0, sscapwh(0), sscapwh(1)
			
			pos 0.14125*sscapwh(0), 0
			gzoom 0.20375*sscapwh(0), 0.05*sscapwh(1), WND_IMAGE_BUF, 0, 0, 163, 24, 1
			if (noHideLv^1){
				pos 0.49375*sscapwh(0), 0.0208333333*sscapwh(1)+0.9
				gzoom 0.125*sscapwh(0), 0.0333333333*sscapwh(1)+0.5, WND_IMAGE_BUF, 0, 24, 100, 16, 1
			}
		}
	} else {
		buffer WND_CAPTURE, sscapwh(0), sscapwh(1)
		gcopy WND_TEMP1, 0, 0, sscapwh(0), sscapwh(1)
	}

	nidPop
	
return 0
	

//SSキャプチャ――――――――――――――――――――――――――――――――――
*SSCapture

	nidPush
	
	gosub *SSCaptureOnMemory
	if (stat): return 1

	successFlg = FALSE

	gsel WND_CAPTURE

	saveName = strf("%s%s", DateAndTimeFormat2(saveNameCapture), savekind(jpgsave))
	
	if (seqCapf == FALSE){
		saveNamePath = ssSaveDir +"\\"+ saveName
		ImgF_ImageSave ssSaveDir +"\\"+ saveName, jpgQuality
	} else {
		saveNamePath = intervalShotDir+"\\"+intervalSaveDir+"\\" +saveName
		ImgF_ImageSave intervalShotDir+"\\"+intervalSaveDir+"\\" +saveName, jpgQuality
	}

	gsel WND_MAIN
	
	if (mode != MODE_OPTION){
		if kmexist(savenamepath) <= 0{
			successFlg = FALSE
			logmessage = savename+"の保存に失敗しました"
		} else {
			successFlg = TRUE
			logmessage = savename+"を保存しました"
			if dispcap & (mode == MODE_SSCAP){
				pos 0, dispcapy
				gzoom Scale(175), Scale(105), WND_CAPTURE, 0, 0, sscapwh(0), sscapwh(1), 1
			}
			
			if (seqcapf^1) {
				
				picHistoryLoad savenamepath
				gosub *TweetWindow
			}
			
		}
		logOut logmessage
	}

	nidPop
return (successFlg^1)


*addCapture

	gsel WND_GRID, 0

	if ( dropFlag & (dropWindowId == 1) ){
		xcnt = dragPoint(0)/cellsize(0) 
		ycnt = dragPoint(1)/cellsize(1)
		dmxy(0) = xcnt, ycnt
		if bufIDPos(xcnt, ycnt) >= 100{
			dmxy(0) = xcnt, ycnt
			loadPicBufID(bufIDPos(xcnt, ycnt)-100) = 0
		}
		
	} else: if ( hotKeyFlag && autoAddCapture){

		repeat
			if (listmode == LISTMODE_LIST){
				ycnt = cnt\ListModeHNum
				xcnt = cnt/ListModeHNum
			} 
			if (listmode == LISTMODE_FLEET){
				if tuika1{
					xcnt = (((cnt\(6*(cellnum(0)+1)/2))/6)*2)+(cnt\2)
					ycnt = ((cnt/((cellnum(0)+1)*3))*3)+((cnt\6)/2)
				}
				if tuika4{
					xcnt = (((cnt\(6*(cellnum(0)+1)/3))/6)*3)+(cnt\3)
					ycnt = ((cnt/((cellnum(0)+1)*2))*2)+((cnt\6)/3)
				}
				if tuika2 {
					xcnt = cnt\6
					ycnt = cnt/6
				}
				if tuika3{
					xcnt = cnt/6
					ycnt = cnt\6
				}
			}
			if (listmode == LISTMODE_OTHER){
				ycnt = cnt\(cellnum(1)+1)
				xcnt = cnt/(cellnum(1)+1)
			} 
			xcnt = limit(xcnt, 0, cellnum(0))
			ycnt = limit(ycnt, 0, cellnum(1))
			if (bufIDPos(xcnt, ycnt) == 0){
				dmxy(0) = xcnt, ycnt
				break
			}
			if (listMode != LISTMODE_LIST){
				if (xcnt=cellnum(0)) & (ycnt=cellnum(1)){
					dmxy(0) = xcnt, ycnt
					loadPicBufID(bufIDPos(xcnt, ycnt)-100) = 0
					break
				}
			} else {
				if (xcnt=cellnum(0)) & (ycnt=(ListModeHNum-1)){
					dmxy(0) = xcnt, ycnt
					loadPicBufID(bufIDPos(xcnt, ycnt)-100) = 0
					break
				}
			}
		loop
		
	}

	repeat (CELL_MAX_W*CELL_MAX_H)
		if loadPicBufID(cnt) = 0{
			loadPicBufID(cnt) = 1
			bufid = cnt +100
			break
		}
	loop
	
	bufIDPos(dmxy(0), dmxy(1)) = bufid
			
	if (hotKeyFlag && autoAddNonSave) {

		gsel WND_CAPTURE
		picx = ginfo_winx
		picy = ginfo_winy
		ratio = 1.0*picy/picx
		
		buffer bufid, 800, 480

		if ( absf(ratio-(450.0/800.0)) <= 0.01 ){
			pos 0, 30
			gzoom 800, 450, WND_CAPTURE, 0, 0, picx, picy, 1
		} else {
			pos 0, 0
			gzoom 800, 480, WND_CAPTURE, 0, 0, picx, picy, 1
		}

		LogOut strf("画像をセル(%d, %d)に読み込みました", dmxy(0), dmxy(1))
		
	} else {
		
		buffer WND_TEMP1
		ImgF_PicloadEx addFileName
		picx = ginfo_winx
		picy = ginfo_winy
		ratio = 1.0*picy/picx
		
		buffer bufid, 800, 480

		if ( absf(ratio-(450.0/800.0)) <= 0.01 ){
			pos 0, 30
			gzoom 800, 450, WND_TEMP1, 0, 0, picx, picy, 1
		} else {
			pos 0, 0
			gzoom 800, 480, WND_TEMP1, 0, 0, picx, picy, 1
		}
		LogOut strf("%sをセル(%d, %d)に読み込みました", getpath(addfilename, 11), dmxy(0), dmxy(1))
		
	}
	gsel WND_GRID
	gosub *draw


return


//ホットキー――――――――――――――――――――――――――――――――――
*hotkey
	nidPush
	
	if (wparam = HOTKEYID) & (availablecap = 1){

		hotKeyFlag = TRUE

		//通常のホットキーによるキャプチャ
		if (mode == MODE_SSCAP){
			gosub *ssCapture
		}

		//一覧作成モードの自動追加ありのキャプチャ
		if ( (mode != MODE_SSCAP) && (mode != MODE_OPTION) && autoAddCapture ) {
			if autoAddNonSave{
				//保存なしの場合
				gosub *SSCaptureOnMemory
			} else {
				//保存ありの場合
				gosub *SSCapture
				addFileName = saveNamePath
			}
			//追加
			gosub *addCapture

		}

		hotKeyFlag = FALSE
		addfilename = ""
	}
	
	nidPop
return

*seqcap

	nidPush
	gsel WND_MAIN, 0
	
	if (seqcapf == FALSE){
		
		seqcapf = TRUE
		
		SetTimer WND_INFO(WND_MAIN, WI_HANDLE), timerID, 100*timersec, 0
		seqcapmes = "停止"
		objprm seqcapBId, seqcapmes
		
		gosub *SSModeControlDisable
	
		chdir intervalShotDir
		intervalsavedir = strf("IntervalShot%04d%02d%02d-%02d%02d%02d", gettime(0), gettime(1), gettime(3), gettime(4), gettime(5), gettime(6))
		if PathIsDirectory(intervalShotDir+"\\"+intervalsavedir) = 0 {
			mkdir intervalsavedir
		}
		chdir currentdir
		
		gosub *ssCapture
	} else {
		
		seqcapf = FALSE
		
		KillTimer WND_INFO(WND_MAIN, WI_HANDLE), timerID
		seqcapmes = "開始"
		objprm seqcapBId, seqcapmes

		gosub *SSModeControlEnable

	}

	nidPop
return