

//SSキャプチャ――――――――――――――――――――――――――――――――――
*ssCapture
	debugLog "SSキャプチャ 開始"
	
	nidPush
	gsel WND_MAIN

	if (positionType == PT_RELATIVE){
		if (IsWindow(hClient) == 0){

			debugLog "    追跡先ウィンドウハンドルが消滅"

			ssCap(0) = 0, 0, 0, 0
			hClient = 0
			ReleaseDC dcClient
			if seqCapf : gosub *seqcap

			gosub *ssSettingCheck
			
			logmessage = "艦これの画面を見失いました"
			if mode != modeOptionNum{
				objprm logid,logmessage
			}

			nidPop
			debugLog "SSキャプチャ 終了"
			return
		}

		GetClientRect hClient, varptr(rect)
		if (clientSize(0) != (rect(2)-rect(0))) | (clientSize(1) != (rect(3)-rect(1))){

			debugLog "    追跡先ウィンドウのサイズが変わった"

			ssCap(0) = 0, 0, 0, 0
			hClient = 0
			ReleaseDC dcClient
			if seqCapf : gosub *seqcap
			
			gosub *ssSettingCheck
			
			logmessage = "艦これの画面を見失いました"
			if mode != modeOptionNum{
				objprm logid,logmessage
			}
			
			nidPop
			debugLog "SSキャプチャ 終了"
			return
		}
			
	}
	
	//暫定数値直接入力
	sscap(0) = luposx
	sscap(1) = luposy
	sscap(2) = rdposx
	sscap(3) = rdposy
	sscapwh(0) = sscap(2)-sscap(0),sscap(3)-sscap(1)

	if (positionType == PT_ABSOLUTE){
		ssCapMes = strf("%d,%d",　sscap(0),　sscap(1))
	} else {
		ssCapMes = "追跡中"
	}
	
	if (mode != modeOptionNum){
		objprm sscapiid, ssCapMes
	}
	
	if (sscapwh(0) < 50) | (sscapwh(1) < 30){
		if mode != modeOptionNum{

			debugLog "    手動座標入力した範囲が小さすぎる"
			
			positionType = 0
			logmessage = "取得範囲が小さすぎます"
			objprm logid,logmessage

			ssCapMes = "取得する"
			if (mode != modeOptionNum){
				objprm sscapiid, ssCapMes
			}
			
		}
		nidPop
		debugLog "SSキャプチャ 終了"
		return
	}
		

	buffer WND_TEMP1, sscapwh(0), sscapwh(1)

	if (positionType == PT_RELATIVE) {
		BitBlt hdc, 0, 0, sscapwh(0), sscapwh(1), dcClient, sscap(0), sscap(1),SRCCOPY:redraw
	} else {
		//PT_ABSOLUTE 絶対座標
		BitBlt hdc, 0, 0, sscapwh(0), sscapwh(1), hdcScreen, sscap(0), sscap(1),SRCCOPY:redraw
	}

	if (hidename == TRUE & isHomeport(WND_TEMP1) == TRUE){

		if (namecut = TRUE) {
			buffer WND_TEMP1, sscapwh(0), int(0.9375*sscapwh(1)+0.5)
			if (positionType == PT_RELATIVE) {
				BitBlt hdc, 0, 0, sscapwh(0), int(0.9375*sscapwh(1)+0.5), dcClient, sscap(0), sscap(1)+(sscapwh(1)-int(0.9375*sscapwh(1)+0.5)), SRCCOPY:redraw
			} else {
				//PT_ABSOLUTE 絶対座標
				BitBlt hdc, 0, 0, sscapwh(0), int(0.9375*sscapwh(1)+0.5), hdcScreen, sscap(0), sscap(1)+(sscapwh(1)-int(0.9375*sscapwh(1)+0.5)), SRCCOPY:redraw
			}
		} else {
			//提督名とレベルを隠す処理
			pos 0.14125*sscapwh(0), 0
			gzoom 0.20375*sscapwh(0), 0.05*sscapwh(1), WND_IMAGE_BUF, 0, 0, 163, 24, 1
			pos 0.49375*sscapwh(0), 0.0208333333*sscapwh(1)+0.9
			gzoom 0.125*sscapwh(0), 0.0333333333*sscapwh(1)+0.5, WND_IMAGE_BUF, 0, 24, 100, 16, 1
			
		}
	
	}

	saveName = strf("%s%s", DateAndTimeFormat2(saveNameCapture), savekind(jpgsave))
	
	if (seqCapf == FALSE){
		saveNamePath = ssSaveDir +"\\"+ saveName
		gdiImageSave ssSaveDir +"\\"+ saveName, jpgQuality
	} else {
		saveNamePath = intervalShotDir+"\\"+intervalSaveDir+"\\" +saveName
		gdiImageSave intervalShotDir+"\\"+intervalSaveDir+"\\" +saveName, jpgQuality
	}

	gsel WND_MAIN
	
	if mode != modeOptionNum{
		if kmexist(savenamepath) <= 0{
			debugLog "    SSの保存失敗"
			logmessage = savename+"の保存に失敗しました"
		} else {
			debugLog "    SSの保存成功"
			logmessage = savename+"を保存しました"
			if dispcap & (mode = 0){
				pos 0,dispcapy
				gzoom Scale(175), Scale(105), WND_TEMP1, 0, 0, sscapwh(0), sscapwh(1), 1
			}
			
			if (seqcapf = 0) {
				i = 99
				repeat 99
					PicHistory(i) = PicHistory(i-1)
					i--
				loop
				PicHistory(0) = savenamepath 
				gosub *TweetWindow
			}
			
		}
		objprm logid,logmessage
	}

	nidPop
	debugLog "SSキャプチャ 終了"
return


*addCapture
	
	gsel WND_GRID,0
	
	if (dropf = 1) & (dropwindowid = 1){
		xcnt = mousex/cellsize(0,listmode) 
		ycnt = mousey/cellsize(1,listmode)
		dmxy(0) = xcnt, ycnt
		if data(xcnt,ycnt,listmode) >= 100{
			dmxy(0) = xcnt, ycnt
			bc(data(xcnt, ycnt,listmode)-100) = 0
		}
	}
	if (autoaddCapture = 1){

		repeat
			if listmode = 0 {
				ycnt = cnt\(cellnum(1,listmode)+1)
				xcnt = cnt/(cellnum(1,listmode)+1)
			} 
			if listmode = 1{
				if tuika1{
					xcnt = (((cnt\(6*(cellnum(0,listmode)+1)/2))/6)*2)+(cnt\2)
					ycnt = ((cnt/((cellnum(0,listmode)+1)*3))*3)+((cnt\6)/2)
				}
				if tuika4{
					xcnt = (((cnt\(6*(cellnum(0,listmode)+1)/3))/6)*3)+(cnt\3)
					ycnt = ((cnt/((cellnum(0,listmode)+1)*2))*2)+((cnt\6)/3)
				}
				if tuika2 {
					xcnt = cnt\6
					ycnt = cnt/6
				}
				if tuika3{
					xcnt = cnt/6
					ycnt = cnt\6
				}
			}
			if listmode = 2 {
				ycnt = cnt\(cellnum(1,listmode)+1)
				xcnt = cnt/(cellnum(1,listmode)+1)
			} 
			xcnt = limit(xcnt,0,cellnum(0,listmode))
			ycnt = limit(ycnt,0,cellnum(1,listmode))
			if data(xcnt,ycnt,listmode) = 0{
				dmxy(0) = xcnt, ycnt
				break
			}
			if (xcnt=cellnum(0,listmode)) & (ycnt=cellnum(1,listmode)){
				dmxy(0) = xcnt, ycnt
				bc(data(xcnt, ycnt,listmode)-100) = 0
				break
			}
		loop
		
	}

	repeat (CELL_MAX_W*CELL_MAX_H*modeNum)
		if bc(cnt) = 0{
			bc(cnt) = 1
			bufid = cnt +100
			break
		}
	loop
	
	data(dmxy(0),dmxy(1),listmode) = bufid
	ImgF_GetPicSize addfilename,picx,picy

	if (picx != 480) & (picy != 450){
		buffer bufid,limit(picx,800,picx),limit(picy,480,picy)
		ImgF_PicloadEx addfilename,1
		gzoom 800,480,bufid,0,0,picx,picy,1
	} else {
		if picy = 480{
			buffer bufid,800,480
			pos 0,0
			ImgF_PicloadEx addfilename,1

		}
		if picy = 450{
			buffer bufid,800,480
			pos 0,30
			ImgF_PicloadEx addfilename,1
		}
	}

	gsel WND_GRID
	gosub *draw
	
	gsel WND_MAIN
	logmessage = strf("%sをセル(%d,%d)に読み込みました",getpath(addfilename,11),dmxy(0),dmxy(1))
	objprm logid,logmessage
	
	gsel WND_GRID

	addfilename = ""
	hotkeyaddf = 0
return


*seqcap
	debugLog "連続キャプチャ設定 開始"
	
	if (seqcapf == FALSE){
		debugLog "    連続キャプチャを開始します"
		SetTimer WND_INFO(WND_MAIN, WI_HANDLE), timerID, 100*timersec, 0
		seqcapmes = "停止"
		objprm seqcapBId,seqcapmes
		objenable comboxId,0
		objenable sscapBId,0
		objenable sscapIId,0
		objenable yabumiBId,0

		///*

		if manualpos & (mode != modeOptionNum) {
			objenable luposxIId, 0
			objenable luposyIId, 0
			objenable rdposxIId, 0
			objenable rdposyIId , 0
		}
		//*/

		
		seqcapf = TRUE
	
		chdir intervalShotDir
		intervalsavedir =  strf("IntervalShot%04d%02d%02d-%02d%02d%02d",gettime(0),gettime(1),gettime(3),gettime(4),gettime(5),gettime(6))
		if PathIsDirectory(intervalShotDir+"\\"+intervalsavedir) = 0 {
			mkdir intervalsavedir
		}
		chdir currentdir
		
		gosub *ssCapture
	} else {
		debugLog "    連続キャプチャを停止します"
		KillTimer WND_INFO(WND_MAIN, WI_HANDLE), timerID
		seqcapmes = "開始"
		objprm seqcapBId,seqcapmes
		objenable comboxId,1
		objenable sscapBId,1
		objenable sscapIId,1
		objenable yabumiBId,1

		if manualpos & (mode != modeOptionNum) {
			objenable luposxIId, 1
			objenable luposyIId, 1
			objenable rdposxIId, 1
			objenable rdposyIId , 1
		}
		
		seqcapf = FALSE
	}

	debugLog "連続キャプチャ設定 終了"
return