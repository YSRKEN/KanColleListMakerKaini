#module VersionCheck

#uselib "advapi32.dll"
#cfunc _CryptAcquireContext "CryptAcquireContextA" var, sptr, sptr, int, int
#cfunc _CryptCreateHash "CryptCreateHash" sptr, int, int, int, var
#cfunc _CryptHashData "CryptHashData" sptr, sptr, int, int
#cfunc _CryptSetHashParam "CryptSetHashParam" sptr, int, var, int
#cfunc _CryptGetHashParam "CryptGetHashParam" sptr, int, sptr, var, int
#cfunc _CryptImportKey "CryptImportKey" sptr, var, int, int, int, var
#func _CryptDestroyKey "CryptDestroyKey" int
#func _CryptDestroyHash "CryptDestroyHash" int
#func _CryptReleaseContext "CryptReleaseContext" int, int
#cfunc _CryptDeriveKey "CryptDeriveKey" int, int, int, int, var
#cfunc _CryptEncrypt "CryptEncrypt" int, int, int, int, int, var, int
#cfunc _CryptDecrypt "CryptDecrypt" int, int, int, int, var, var
//---------------
//  wininet.dll
//---------------
#uselib "wininet.dll"
#cfunc _InternetOpen "InternetOpenA" sptr, int, sptr, sptr, int
#cfunc _InternetOpenUrl "InternetOpenUrlA" int, str, sptr, int, int, int
#func _InternetReadFile "InternetReadFile" int, var, int, var
#func _InternetCloseHandle "InternetCloseHandle" int
#cfunc _InternetConnect "InternetConnectA" int, str, int, sptr, sptr, int, int, int
#cfunc _HttpOpenRequest "HttpOpenRequestA" int, sptr, str, sptr, sptr, sptr, int, int
#cfunc _HttpSendRequest "HttpSendRequestA" int, sptr, int, sptr, int
#cfunc _HttpQueryInfo "HttpQueryInfoA" int, int, var, var, int
#func _InternetQueryDataAvailable "InternetQueryDataAvailable" int, var, int, int
#func _InternetSetOption "InternetSetOptionA" int, int, int, int

#define INTERNET_OPEN_TYPE_DIRECT               1
#define INTERNET_OPTION_CONNECT_TIMEOUT         2
#define INTERNET_OPTION_HTTP_DECODING           65
#define INTERNET_DEFAULT_HTTP_PORT              80
#define INTERNET_DEFAULT_HTTPS_PORT             443
#define INTERNET_SERVICE_HTTP                   3
#define INTERNET_FLAG_RELOAD                    0x80000000
#define INTERNET_FLAG_SECURE                    0x00800000
#define INTERNET_FLAG_NO_CACHE_WRITE            0x04000000
#define INTERNET_FLAG_DONT_CACHE                INTERNET_FLAG_NO_CACHE_WRITE
#define INTERNET_FLAG_IGNORE_CERT_DATE_INVALID  0x00002000
#define INTERNET_FLAG_IGNORE_CERT_CN_INVALID    0x00001000

#define HTTP_QUERY_MIME_VERSION 0
#define HTTP_QUERY_CONTENT_TYPE 1
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING 2
#define HTTP_QUERY_CONTENT_ID 3
#define HTTP_QUERY_CONTENT_DESCRIPTION 4
#define HTTP_QUERY_CONTENT_LENGTH 5
#define HTTP_QUERY_CONTENT_LANGUAGE 6
#define HTTP_QUERY_ALLOW 7
#define HTTP_QUERY_PUBLIC 8
#define HTTP_QUERY_DATE 9
#define HTTP_QUERY_EXPIRES 10
#define HTTP_QUERY_LAST_MODIFIED 11
#define HTTP_QUERY_MESSAGE_ID 12
#define HTTP_QUERY_URI 13
#define HTTP_QUERY_DERIVED_FROM 14
#define HTTP_QUERY_COST 15
#define HTTP_QUERY_LINK 16
#define HTTP_QUERY_PRAGMA 17
#define HTTP_QUERY_VERSION 18
#define HTTP_QUERY_STATUS_CODE 19
#define HTTP_QUERY_STATUS_TEXT 20
#define HTTP_QUERY_RAW_HEADERS 21
#define HTTP_QUERY_RAW_HEADERS_CRLF 22
#define HTTP_QUERY_CONNECTION 23
#define HTTP_QUERY_ACCEPT 24
#define HTTP_QUERY_ACCEPT_CHARSET 25
#define HTTP_QUERY_ACCEPT_ENCODING 26
#define HTTP_QUERY_ACCEPT_LANGUAGE 27
#define HTTP_QUERY_AUTHORIZATION 28
#define HTTP_QUERY_CONTENT_ENCODING 29
#define HTTP_QUERY_FORWARDED 30
#define HTTP_QUERY_FROM 31
#define HTTP_QUERY_IF_MODIFIED_SINCE 32
#define HTTP_QUERY_LOCATION 33
#define HTTP_QUERY_ORIG_URI 34
#define HTTP_QUERY_REFERER 35
#define HTTP_QUERY_RETRY_AFTER 36
#define HTTP_QUERY_SERVER 37
#define HTTP_QUERY_TITLE 38
#define HTTP_QUERY_USER_AGENT 39
#define HTTP_QUERY_WWW_AUTHENTICATE 40
#define HTTP_QUERY_PROXY_AUTHENTICATE 41
#define HTTP_QUERY_ACCEPT_RANGES 42
#define HTTP_QUERY_SET_COOKIE 43
#define HTTP_QUERY_COOKIE 44
#define HTTP_QUERY_REQUEST_METHOD 45
#define HTTP_QUERY_MAX 45
#define HTTP_QUERY_CUSTOM 65535
#define HTTP_QUERY_FLAG_REQUEST_HEADERS 0x80000000
#define HTTP_QUERY_FLAG_SYSTEMTIME 0x40000000
#define HTTP_QUERY_FLAG_NUMBER 0x20000000
#define HTTP_QUERY_FLAG_COALESCE 0x10000000
#define HTTP_QUERY_MODIFIER_FLAGS_MASK (HTTP_QUERY_FLAG_REQUEST_HEADERS|HTTP_QUERY_FLAG_SYSTEMTIME|HTTP_QUERY_FLAG_NUMBER|HTTP_QUERY_FLAG_COALESCE)
#define HTTP_QUERY_HEADER_MASK (~HTTP_QUERY_MODIFIER_FLAGS_MASK)


//============================================================
/*  [HDL symbol infomation]

%index
tCupInit
TsubuyakiSoupの初期化

%prm
p1, p2, p3
p1 = 文字列      : ユーザエージェント
p2 = 文字列      : Consumer Key
p3 = 文字列      : Consumer Secret
p4 = 0〜(30)     : タイムアウトの時間(秒)

%inst
TsubyakiSoupモジュールの初期化をします。Twitter操作命令の使用前に呼び出す必要があります。

p1にユーザエージェントを指定します。ユーザエージェントを指定していないとSearchAPIなどで厳しいAPI制限を受けることがあります。

p2にConsumer Keyを、p3にConsumer Secretを指定してください。Consumer KeyとConsumer Secretは、Twitterから取得する必要があります。詳しくは、リファレンスをご覧ください。

p4にはTwitterと通信する際のタイムアウトの時間を秒単位で指定してください。

%href
TS_End

%group
TwitterAPI操作命令

%*/
//------------------------------------------------------------
#deffunc VerCheckInit
	//各種変数の初期化
;	rateLimit(0) = -1		// 15分間にAPIを実行できる回数
;	rateLimit(1) = -1		// APIを実行できる残り回数
;	rateLimit(2) = -1		// リセットする時間

	responseHeader = ""
	responseBody = ""
	timeOutTime = 2000
	gzipFlag = 1 // true /-------------------
	//インターネットオープン
	hInet = _InternetOpen( p1, INTERNET_OPEN_TYPE_DIRECT, 0, 0, 0)
	if hInet = 0:return -1
	_InternetSetOption hInet, INTERNET_OPTION_CONNECT_TIMEOUT, varptr(timeOutTime), 4
	_InternetSetOption hInet, INTERNET_OPTION_HTTP_DECODING, varptr(gzipFlag), 4
return 0
//============================================================




//============================================================
/*  [HDL symbol infomation]

%index
tCupWash
TsubuyakiSoupの終了処理

%inst
TsubyakiSoupモジュールの終了処理を行ないます。
プログラム終了時に自動的に呼び出されるので明示的に呼び出す必要はありません。

%href
TS_Init

%group
TwitterAPI操作命令

%*/
//------------------------------------------------------------
#deffunc VerCheckWash onexit
	//ハンドルの破棄
	if (hRequest) : _InternetCloseHandle hRequest
	if (hConnect) : _InternetCloseHandle hConnect
	if (hInet) : _InternetCloseHandle hInet
return
//============================================================
// str   p1 API
// array p2 argument
// int   p3 http method
#deffunc execVerCheck

	hConnect = 0	// InternetConnectのハンドル
	hRequest = 0	// HttpOpenRequestのハンドル
	statcode = 0	// リクエストの結果コード
	dataLength = 0	// データ長
	rsize = 1024	// バッファ初期値
	hsize = 0		// 取得したバイト数が代入される変数
	
	RequestURL = "drive.google.com"

	apiUrl = "uc?export=download&id=0BxC9-Nilt2alT1JlVG9MNlE4OWM"
	
	usePort = 443
	requestFlag  = INTERNET_FLAG_RELOAD
	requestFlag |= INTERNET_FLAG_DONT_CACHE
	requestFlag |= INTERNET_FLAG_IGNORE_CERT_DATE_INVALID
	requestFlag |= INTERNET_FLAG_IGNORE_CERT_CN_INVALID
	requestFlag |= INTERNET_FLAG_SECURE

	RequestHeader = "Accept-Encoding: gzip, deflate;\nContent-Type: application/x-www-form-urlencoded"
	RequestHeaderLength = strlen(RequestHeader)
	PostData = 0
	PostDataLength = 0
	
	//サーバへ接続
	hConnect = _InternetConnect(hInet, RequestURL, INTERNET_DEFAULT_HTTPS_PORT, 0, 0, INTERNET_SERVICE_HTTP, 0, 0)
	if (hConnect = 0) {
		//Connectハンドルを取得できなかった場合
		return -4
	}
	
	//リクエストの初期化
	hRequest = _HttpOpenRequest(hConnect, method, apiUrl, "HTTP/1.1", 0, 0, requestFlag, 0)
	if (hRequest = 0) {
		//Requestハンドルを取得できなかった場合
		_InternetCloseHandle hConnect
		return -3
	}
	
	//サーバへリクエスト送信
	if ( _HttpSendRequest(hRequest, RequestHeader, RequestHeaderLength, PostData, PostDataLength)) {
		//ヘッダを取得する変数の初期化
		responseHeaderSize = 3000
		sdim responseHeader, responseHeaderSize
		//ヘッダの取得
		if ( _HttpQueryInfo(hRequest, HTTP_QUERY_RAW_HEADERS_CRLF, responseHeader, responseHeaderSize, 0) ) {
			//ヘッダの解析
			notesel responseHeader
			repeat notemax
				noteget headerLine, cnt
				headerTokenPos = instr(headerLine, 0, "HTTP/1.1 ")				//ステータスコード
				if (headerTokenPos != -1) : statcode = int(strmid(headerLine, headerTokenPos+9, 3))
				headerTokenPos = instr(headerLine, 0, "content-length: ")		//長さ
				if (headerTokenPos != -1) : responseBodyLength = int(strmid(headerLine, -1, strlen(headerLine)-headerTokenPos+16))
			loop
			noteunsel
			logmes ""+responseBodyLength
			//入手可能なデータ量を取得
			_InternetQueryDataAvailable hRequest, rsize, 0, 0
			//バッファの初期化
			logmes "srize : "+ rsize
			sdim responseBuffer, rsize+1
			sdim responseBody, 10240
			repeat 
				_InternetReadFile hRequest, responseBuffer, rsize, hsize
				if (hsize = 0) : break 
				responseBody += strmid(responseBuffer, 0, hsize)
			loop
		} else {
			//ヘッダの取得ができなかった場合
			return -1
		}
		//Requestハンドルの破棄
		_InternetCloseHandle hRequest
	} else {
		//サーバへリクエスト送信できなかった場合
		return -2
	}
return statcode

//===========================================================

#defcfunc getResponse
return responseBody

#global


*VerCheck

	if autoVersionCheck {

		debugLog "バージョンチェック 開始"
		
		VerCheckInit

		if (mode == MODE_SSCAP){
			logmessage = "バージョンチェック中です。"
			objprm logId, logMessage:await 
		}
		
		execVerCheck
		if stat = 200{
			logmes "アップデートファイルの取得成功"
			sdim json,1024*4
			json = getResponse()
			json_sel json
			
			logmes "取得したバージョン " + json_val("[0].version")
			debugLog "    取得したバージョン" + json_val("[0].version")
			if klm2ver < int(json_val("[0].version")){
				
				sdim text,1024
				text =  "艦これ一覧めいかー改二の最新版"+json_val("[0].versionstr")+"が公開されています\n"
				text += json_val("[0].comment")
				text += "\nダウンロードページを開きますか？"
				
				dialog text,2,"最新版が公開されています"
				if stat = 6{
					exec ""+json_val("[0].distributionurl"),16
				}
			}
			json_unsel
			sdim json
			sdim text
		} else {
			logmes "アップデートファイルの取得失敗"
			dialog "次の原因が考えられます\nアップデート情報配信サーバーのダウン\nインターネット未接続",0,"アップデート情報の取得に失敗しました"
		}
		VerCheckWash

		if (mode == MODE_SSCAP){
			logmessage = "バージョンチェックが完了しました。"
			objprm logId, logMessage
		}
		
		debugLog "バージョンチェック 終了"
	}

return